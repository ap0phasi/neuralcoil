rdim=dim(CoilVals)[1]
new_weights[511]=new_weights[511]+2
state.sel=1
matplot(pop_coil_full(new_weights)[[1]][,state.sel],pch=1,type="l",xlim=c(0,(Tlen)),lwd=2,ylim=c(0,1),xlab="Time",ylab=paste("State",state.sel,"Probability"),col="blue")
matlines(Pmat[,state.sel],lwd=2,type="l",xlim=c(0,(Tlen)),xlab="Time",ylab="P(s)",col="black")
legend("topright",col=c("blue","black"),c("New Rotation","Old Rotation"),lwd=2)
new_weights=best_weights
rdim=dim(CoilVals)[1]
new_weights[511]=new_weights[511]*2
state.sel=1
matplot(pop_coil_full(new_weights)[[1]][,state.sel],pch=1,type="l",xlim=c(0,(Tlen)),lwd=2,ylim=c(0,1),xlab="Time",ylab=paste("State",state.sel,"Probability"),col="blue")
matlines(Pmat[,state.sel],lwd=2,type="l",xlim=c(0,(Tlen)),xlab="Time",ylab="P(s)",col="black")
legend("topright",col=c("blue","black"),c("New Rotation","Old Rotation"),lwd=2)
new_weights=best_weights
rdim=dim(CoilVals)[1]
new_weights[511]=new_weights[511]*2
state.sel=1
matplot(pop_coil_full(new_weights)[[1]][,state.sel],pch=1,type="l",xlim=c(0,(Tlen)),lwd=2,ylim=c(0,1),xlab="Time",ylab=paste("State",state.sel,"Probability"),col="blue")
matlines(Pmat[,state.sel],lwd=2,type="l",xlim=c(0,(Tlen)),xlab="Time",ylab="P(s)",col="black")
legend("topright",col=c("blue","black"),c("New Rotation","Old Rotation"),lwd=2)
new_weights=best_weights
rdim=dim(CoilVals)[1]
new_weights[511]=new_weights[511]*20
state.sel=1
matplot(pop_coil_full(new_weights)[[1]][,state.sel],pch=1,type="l",xlim=c(0,(Tlen)),lwd=2,ylim=c(0,1),xlab="Time",ylab=paste("State",state.sel,"Probability"),col="blue")
matlines(Pmat[,state.sel],lwd=2,type="l",xlim=c(0,(Tlen)),xlab="Time",ylab="P(s)",col="black")
legend("topright",col=c("blue","black"),c("New Rotation","Old Rotation"),lwd=2)
new_weights=best_weights
rdim=dim(CoilVals)[1]
new_weights[511]=new_weights[511]+0.1
state.sel=1
matplot(pop_coil_full(new_weights)[[1]][,state.sel],pch=1,type="l",xlim=c(0,(Tlen)),lwd=2,ylim=c(0,1),xlab="Time",ylab=paste("State",state.sel,"Probability"),col="blue")
matlines(Pmat[,state.sel],lwd=2,type="l",xlim=c(0,(Tlen)),xlab="Time",ylab="P(s)",col="black")
legend("topright",col=c("blue","black"),c("New Rotation","Old Rotation"),lwd=2)
new_weights=best_weights
rdim=dim(CoilVals)[1]
new_weights[511]=new_weights[511]+5
state.sel=1
matplot(pop_coil_full(new_weights)[[1]][,state.sel],pch=1,type="l",xlim=c(0,(Tlen)),lwd=2,ylim=c(0,1),xlab="Time",ylab=paste("State",state.sel,"Probability"),col="blue")
matlines(Pmat[,state.sel],lwd=2,type="l",xlim=c(0,(Tlen)),xlab="Time",ylab="P(s)",col="black")
legend("topright",col=c("blue","black"),c("New Rotation","Old Rotation"),lwd=2)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(neuralcoil)
#Load in Ball-in-Box data:
data("exampledata_ballinbox")
out_goal=as.numeric(exampledata_ballinbox)
matplot(exampledata_ballinbox,type="l",lwd=2,xlab = "Time",ylab="Probability",main="State Probability Dynamics")
legend("topright", colnames(P.df),col=seq_len(dim(P.df)[2]),cex=0.8,fill=seq_len(dim(P.df)[2]))
#User Selections----
n.s=dim(exampledata_ballinbox)[2]#number of states
sym=F   #Parameter Symmetry
loc=F #Locality
cont=T #Parameter Physicality Controls
sub.num=1 #Number of conserved subgroups
vfara_inert=1 #inertia
vfara_init=1 #initial inertia
Tlen=dim(exampledata_ballinbox)[1] #Steps to run coil
buildcoil(n.s,sym=F)
#Number of needed parameters
L=dim(CoilVals)[1]*2+3+n.s*2
retrain=F
if (retrain){
#Particle Swarm Optimizer
n.part=100#number of particles
w=0.9 #velocity factor
g_p=0.4#position influence factor
g_g=0.4#swarm influence factor
initialize_swarm_full(n.part,L,setrots=c(2,5,5))
for (itt in 1:10){
if (itt<400){
slseq=array(matrix(seq(1:length(out_goal)),ncol=n.s)[1:round(Tlen/2),])
#slseq=c(1:15,26:36,51:61,76:86)
}else{
slseq=1:length(out_goal)
}
#slseq=1:length(out_goal)
step_swarm_full(n.part,L,setrots=c(2,5,5))
matplot(t(outmat),col="grey",lty=1,type="l")
lines(out_goal,col="blue")
print(itt)
}
best_weights=best_p[which.min(apply(best_p_res,1,function(x)optf(x,out_goal,slseq))),]
}else{
best_weights=readRDS("../results/ballinbox_weights_final.RdA")
}
coil_out=pop_coil_full(best_weights)
Pmat=coil_out[[1]]
complex_states=coil_out[[2]]
matplot(Pmat,type="l",lwd=2,xlab = "Time",ylab="Probability",main="State Probability Dynamics")
matlines(exampledata_ballinbox)
legend("topright", colnames(P.df),col=seq_len(dim(P.df)[2]),cex=0.8,fill=seq_len(dim(P.df)[2]))
par(mfrow = c(2, 2))
for (iP in 1:dim(Pmat)[2]){
plot(exampledata_ballinbox[,iP],type="l",xlab="Time",ylab="Probability",main = paste("State",iP,"Dynamics "))
lines(Pmat[,iP],lty=2)
}
par(mfrow = c(1,1))
ylims=c(min(Re(complex_states),Im(complex_states)),max(Re(complex_states),Im(complex_states)))
ylims[2]=ylims[2]+0.1
for (itt in 1:Tlen){
barplot(Pmat[itt,],space=0,ylab="Value",xlab="State",ylim=ylims)
lines(seq(0.5,length(complex_states[itt,])-0.5,1),Im(complex_states[itt,]),col="blue",lwd=2)
lines(seq(0.5,length(complex_states[itt,])-0.5,1),Re(complex_states[itt,]),col="red",lwd=2)
legend("bottomright",col=c("red","blue"),c("Real","Imaginary"),lty=1,lwd=2)
}
new_weights=best_weights
rdim=dim(CoilVals)[1]
new_weights[(rdim*2+1):(rdim*2+3)]=c(2,5.00001,5)
state.sel=1
matplot(pop_coil_full(new_weights)[[1]][,state.sel],pch=1,type="l",xlim=c(0,(Tlen)),lwd=2,ylim=c(0,1),xlab="Time",ylab=paste("State",state.sel,"Probability"),col="blue")
matlines(Pmat[,state.sel],lwd=2,type="l",xlim=c(0,(Tlen)),xlab="Time",ylab="P(s)",col="black")
legend("topright",col=c("blue","black"),c("New Rotation","Old Rotation"),lwd=2)
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy.R")
Normsave
Normsaves
n.s
n.s^2+n.s
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy.R")
outsave=c()
par(mfrow=c(length(inputlist),1),mar=c(0,4,0,0))
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l")
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
par(mfrow=c(1,1),mar=c(4,4,4,4))
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5)
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
#=lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invobs,col="blue")
}
print(paste("Difference:",sum((model%>%predict(nn_inputs))[1,]-nn_obj[1,])))
print(paste("Difference 2:",sum((model%>%predict(nn_inputs))[1,1:13]-nn_obj[1,1:13])))
# #Checks
# nn_out=(model%>%predict(nn_inputs))
# stmat=matrix(nn_obj[1,4:11],nrow=2)
# startvals<-(complex(n.s,stmat[1,],stmat[2,]))
# Rmat=matrix(nn_obj[1,12:dim(nn_obj)[2]],nrow=2)
# rvecnew=complex(length(RandVec),Rmat[1,],Rmat[2,])
# plot(runcoil(rvecnew,nn_obj[1,1:3],startvals)[[1]][,1])
# lines(runcoil(RandVec,nn_obj[1,1:3],startvals)[[1]][,1])
# stmat=matrix(nn_out[1,4:11],nrow=2)
# startvals<-(complex(n.s,stmat[1,],stmat[2,]))
# Rmat=matrix(nn_out[1,12:dim(nn_out)[2]],nrow=2)
# rvecnew=complex(length(RandVec),Rmat[1,],Rmat[2,])
# lines(runcoil(rvecnew,nn_out[1,1:3],startvals)[[1]][,1],col="blue")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy.R")
nn_obj
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy.R")
inout
dfs
model
n.s
params
dfs
scaledat
dfw
dfs
dfs
scaleran
dfw
scaleddat
scaledat
dfw
dim(nn_inputs)
nn_inputs
nn_obj
nn_inputs
model<-autogen_cnn(dfs,n.s,dim(CoilVals)[1])
weights<-get_weights(model)
weights
outsave=c()
par(mfrow=c(length(inputlist),1),mar=c(0,4,0,0))
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l")
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
par(mfrow=c(1,1),mar=c(4,4,4,4))
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5)
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
#=lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invobs,col="blue")
}
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
inputs
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
nn_obj[,]
nn_obj[,-c(1:13)]
model%>%predict(nn_inputs))[1,]
model%>%predict(nn_inputs))
model%>%predict(nn_inputs)
nn_obj[,-c(1:13)]
model%>%predict(nn_inputs)
plot(model%>%predict(nn_inputs))
model%>%predict(nn_inputs)
dim(model%>%predict(nn_inputs))
plot(model%>%predict(nn_inputs)[1,])
plot((model%>%predict(nn_inputs))[1,])
plot((model%>%predict(nn_inputs))[1,-1:4])
plot((model%>%predict(nn_inputs))[1,-c(1:4)])
lines(nn_obj[1,-c(1:4)])
nn_obj[1,-c(1:4)]-(model%>%predict(nn_inputs))[1,-c(1:4)]
sum(nn_obj[1,-c(1:4)]-(model%>%predict(nn_inputs))[1,-c(1:4)])
nn_inputs
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
sum(nn_obj[1,-c(1:4)]-(model%>%predict(nn_inputs))[1,-c(1:4)])
nn_obj[1,-c(1:4)]-(model%>%predict(nn_inputs))[1,-c(1:4)]
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
nn_inputs
nn_obj
rots
nn_obj
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
nn_obj
nn_obj[,1]
nn_obj[,2]
nn_obj[,651]
stvals
nn_obj=cbind(rots/10,stvals*10,RandMat)
loss_focus<-function(y_true,y_pred){
importance_vector=rep(1,(n.s*2+3))
importance_vector[4:(n.s*2+3)]=100000
k_mean((y_true[,1:(n.s*2+3)]-y_pred[,1:(n.s*2+3)])^2*importance_vector)
}
print(paste("Difference:",sum((model%>%predict(nn_inputs))[1,]-nn_obj[1,])))
model %>%compile(loss=loss_focus,optimizer="adam")
history<-model%>%fit(
nn_inputs,
nn_obj,
epochs=1000,
batch_size=1
)
nn_obj=cbind(rots/10,stvals,RandMat)
loss_focus<-function(y_true,y_pred){
importance_vector=rep(1,(n.s*2+3))
importance_vector[4:(n.s*2+3)]=100000
k_mean((y_true[,1:(n.s*2+3)]-y_pred[,1:(n.s*2+3)])^2*importance_vector)
}
print(paste("Difference:",sum((model%>%predict(nn_inputs))[1,]-nn_obj[1,])))
model %>%compile(loss=loss_focus,optimizer="adam")
history<-model%>%fit(
nn_inputs,
nn_obj,
epochs=1000,
batch_size=1
)
nn_obj=cbind(rots,stvals,RandMat)
loss_focus<-function(y_true,y_pred){
importance_vector=rep(1,(n.s*2+3))
importance_vector[4:(n.s*2+3)]=100000
k_mean((y_true[,1:(n.s*2+3)]-y_pred[,1:(n.s*2+3)])^2*importance_vector)
}
print(paste("Difference:",sum((model%>%predict(nn_inputs))[1,]-nn_obj[1,])))
model %>%compile(loss=loss_focus,optimizer="adam")
history<-model%>%fit(
nn_inputs,
nn_obj,
epochs=1000,
batch_size=1
)
outsave=c()
par(mfrow=c(length(inputlist),1),mar=c(0,4,0,0))
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l")
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
par(mfrow=c(1,1),mar=c(4,4,4,4))
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5)
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
#=lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invobs,col="blue")
}
print(paste("Difference:",sum((model%>%predict(nn_inputs))[1,]-nn_obj[1,])))
print(paste("Difference 2:",sum((model%>%predict(nn_inputs))[1,1:13]-nn_obj[1,1:13])))
# #Checks
# nn_out=(model%>%predict(nn_inputs))
# stmat=matrix(nn_obj[1,4:11],nrow=2)
# startvals<-(complex(n.s,stmat[1,],stmat[2,]))
# Rmat=matrix(nn_obj[1,12:dim(nn_obj)[2]],nrow=2)
# rvecnew=complex(length(RandVec),Rmat[1,],Rmat[2,])
# plot(runcoil(rvecnew,nn_obj[1,1:3],startvals)[[1]][,1])
# lines(runcoil(RandVec,nn_obj[1,1:3],startvals)[[1]][,1])
# stmat=matrix(nn_out[1,4:11],nrow=2)
# startvals<-(complex(n.s,stmat[1,],stmat[2,]))
# Rmat=matrix(nn_out[1,12:dim(nn_out)[2]],nrow=2)
# rvecnew=complex(length(RandVec),Rmat[1,],Rmat[2,])
# lines(runcoil(rvecnew,nn_out[1,1:3],startvals)[[1]][,1],col="blue")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
get_params<-function(input){
rdim<-dim(CoilVals)[1]
val_out=model(input, training = TRUE)
cnn_outputs <- as.array(val_out)
rots<-abs(cnn_outputs[1:3])*10
stv<-cnn_outputs[(4):(4+n.s*2-1)]
rvs<-cnn_outputs[(4+n.s*2):length(cnn_outputs)]
stmat<-(matrix(stv,nrow=2))
startvals<-(complex(n.s,stmat[1,],stmat[2,]))
randmat<-(matrix(rvs,nrow=2))
RandVec<-complex(rdim,randmat[1,],randmat[2,])
return(list(RandVec=RandVec,rots=rots,startvals=startvals))
}
outsave=c()
par(mfrow=c(length(inputlist),1),mar=c(0,4,0,0))
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l")
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
par(mfrow=c(1,1),mar=c(4,4,4,4))
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5)
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
#=lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invobs,col="blue")
}
print(paste("Difference:",sum((model%>%predict(nn_inputs))[1,]-nn_obj[1,])))
print(paste("Difference 2:",sum((model%>%predict(nn_inputs))[1,1:13]-nn_obj[1,1:13])))
get_params<-function(input){
rdim<-dim(CoilVals)[1]
val_out=model(input, training = TRUE)
cnn_outputs <- as.array(val_out)
rots<-abs(cnn_outputs[1:3])*10
stv<-cnn_outputs[(4):(4+n.s*2-1)]
rvs<-cnn_outputs[(4+n.s*2):length(cnn_outputs)]
stmat<-(matrix(stv,nrow=2))
startvals<-(complex(n.s,stmat[1,],stmat[2,]))
randmat<-(matrix(rvs,nrow=2))
RandVec<-complex(rdim,randmat[1,],randmat[2,])
return(list(RandVec=RandVec,rots=rots,startvals=startvals))
}
outsave=c()
par(mfrow=c(length(inputlist),1),mar=c(0,4,0,0))
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l")
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
par(mfrow=c(1,1),mar=c(4,4,4,4))
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5)
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
#=lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invobs,col="blue")
}
print(paste("Difference:",sum((model%>%predict(nn_inputs))[1,]-nn_obj[1,])))
print(paste("Difference 2:",sum((model%>%predict(nn_inputs))[1,1:13]-nn_obj[1,1:13])))
get_params()
?get_params
get_params
get_params<-function(input){
rdim<-dim(CoilVals)[1]
val_out=model(input, training = TRUE)
cnn_outputs <- as.array(val_out)
rots<-abs(cnn_outputs[1:3])
stv<-cnn_outputs[(4):(4+n.s*2-1)]
rvs<-cnn_outputs[(4+n.s*2):length(cnn_outputs)]
stmat<-(matrix(stv,nrow=2))
startvals<-(complex(n.s,stmat[1,],stmat[2,]))
randmat<-(matrix(rvs,nrow=2))
RandVec<-complex(rdim,randmat[1,],randmat[2,])
return(list(RandVec=RandVec,rots=rots,startvals=startvals))
}
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
nn_obj[1,-c(1:4)]-(model%>%predict(nn_inputs))[1,-c(1:4)]
outsave=c()
par(mfrow=c(length(inputlist),1),mar=c(0,4,0,0))
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l")
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
assign_weights(weights,weightdim,savedweights)
outsave=c()
par(mfrow=c(length(inputlist),1),mar=c(0,4,0,0))
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l")
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
par(mfrow=c(1,1),mar=c(4,4,4,4))
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5)
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
#=lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invobs,col="blue")
}
assign_weights(weights,weightdim,readRDS("results/buoy_opt5.RdA"))
outsave=c()
par(mfrow=c(length(inputlist),1),mar=c(0,4,0,0))
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l")
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
par(mfrow=c(1,1),mar=c(4,4,4,4))
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5)
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
#=lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invobs,col="blue")
}
assign_weights(weights,weightdim,readRDS("results/buoy_opt5.RdA"))
get_weights(model)
aa=readRDS("results/buoy_opt5.RdA")
aa[[16]]
aa
length(unlist(get_weights(model)))
length(aa)
aa[125236]
aa[12523]
unlist(get_weights(model))[12523]
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
bestp[which.min(bestgs),]
transform_to_params(bestp[which.min(bestgs),],inputlist)
bestp[which.min(bestgs),]
length(bestp[which.min(bestgs),])
inputlist
length(inputlist)
avec=bestp[which.min(bestgs),]
inL<-length(inputlist)
rot.indx<-1:(inL*3)
st.indx<-(inL*3+1):length(avec)
matrix(avec[rot.indx],ncol=3)
matrix(avec[st.indx],ncol=2*n.s)
inL
(inL*3+1):length(avec)
length((inL*3+1):length(avec))
length(avec)
dim(bestp)
eval_params
avec<-c(rep(rotvals_opt,length(xsamps)),rep(c(Re(startvals_opt),Im(startvals_opt)),length(xsamps)))
length(avec)
initialize_swarm(n.part,type="direct")
lowlim
uplim
x.p
n.part=20
initialize_swarm(n.part,type="direct")
Esave=c()
for (itt in 1:100){
step_swarm(n.part,type="direct")
Esave=c(Esave,min(bestgs))
plot(Esave,type="l")
#plot(x.p[,c(1,2)])
}
dim(bestp)
opt_params<-transform_to_params(bestp[which.min(bestgs),],inputlist)
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
source("~/GitHub/neuralcoil/tests/fullstack_pso_buoy_experiment2.R")
