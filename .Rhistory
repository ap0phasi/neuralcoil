#We will use a custom loss function because we already know our coil parameters, so we can ignore those.
loss_focus<-function(y_true,y_pred){
importance_vector=rep(1,(n.s*2+3))
importance_vector[4:(n.s*2+3)]=100000
k_mean((y_true[,1:(n.s*2+3)]-y_pred[,1:(n.s*2+3)])^2*importance_vector)
}
retrain=F
if(retrain){
model %>%compile(loss=loss_focus,optimizer="adam")
history<-model%>%fit(
nn_inputs,
nn_obj,
epochs=1000,
batch_size=1
)
}else{
set_weights(model,readRDS("../results/buoy_full_neural.RdA"))
}
nn_inputs=sapply(1:length(inputlist[[1]]),function(g) do.call(rbind,lapply(inputlist,function(x)x[[g]])))
RandMat=t(matrix(rep(array(t(matrix(c(Re(RandVec),Im(RandVec)),ncol=2))),length(xsamps)),ncol=length(xsamps)))
nn_obj=cbind(rots,stvals,RandMat)
#We will use a custom loss function because we already know our coil parameters, so we can ignore those.
loss_focus<-function(y_true,y_pred){
importance_vector=rep(1,(n.s*2+3))
importance_vector[4:(n.s*2+3)]=100000
k_mean((y_true[,1:(n.s*2+3)]-y_pred[,1:(n.s*2+3)])^2*importance_vector)
}
retrain=F
if(retrain){
model %>%compile(loss=loss_focus,optimizer="adam")
history<-model%>%fit(
nn_inputs,
nn_obj,
epochs=1000,
batch_size=1
)
}else{
set_weights(model,readRDS("../results/buoy_full_neural.RdA"))
}
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
xsamps
xsamps=c(3,72,44,68,150)
inout<-gen_in_out(dfs,xsamps)
dfs
xsamps=c(3,72,44)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
dfs
xsamps=c(3,72,44,72)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
xsamps=c(3,72,44,72)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
print(coil_out[[1]][1,1])
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
xsamps=c(3,72,44,72)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
xsamps=c(3,72,44,80)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
xsamps=c(3,72,44,100)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
xsamps=c(3,72,44,120)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
xsamps=c(3,72,44,112)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
xsamps=c(3,72,44)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
xsamps=c(3,72,44)+5
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(neuralcoil)
library(gifski)
library(kableExtra)
library(keras)
library(tensorflow)
library(lubridate)
library(dplyr)
data("data_buoy",package="forecastML")
clean=data_buoy
clean[is.na(clean)]=0
clean$group=lubridate::floor_date(data_buoy$date,"10 day")
clean<-as.data.frame(clean%>%group_by(group)%>%summarise_all(mean))
head(clean)
lookback=10
lookforward=30
slen=30 #How many samples in the lookforward to use?
slseq=round(seq(1,lookforward,length.out = slen))
states=1 #Which states to calibrate to?
predictors=c("wind_spd","air_temperature")
objective=c("sea_surface_temperature")
df=clean%>%select(c(predictors,objective))
df=df[df$sea_surface_temperature>0,]
dfw<-lookwindow(df,lookback,lookforward,predictors,objective)
scaleran=c(0.2,0.6)
scaledat<-scalelist(dfw,objrange=scaleran)
scalesaves<-scaledat$scalesaves
dfs<-scaledat$scaledlist
#User Selections----
n.s=4#number of states
sym=F   #Parameter Symmetry
loc=F #Locality
cont=T #Parameter Physicality Controls
sub.num=1 #Number of conserved subgroups
vfara_inert=60#inertia
vfara_init=100 #initial inertia
Tlen=lookforward #Steps to run coil
loadvals=T #Load in previously learned values?
if (loadvals){
savedweights<-readRDS("../results/buoy_single_final.RdA")
}
retrain=F #Retrain from saved weights?
buildcoil(n.s,sym=sym)
model<-autogen_cnn(dfs,n.s,dim(CoilVals)[1])
weights<-get_weights(model)
weightdim=lapply(weights, dim)
avec<-unlist(weights)
xsamps=c(3) #what timestep do we want to train for?
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
if (loadvals&!retrain){
assign_weights(weights,weightdim,savedweights)
}else{
n.part=20
initialize_swarm(n.part)
Esave=c()
for (itt in 1:100){
step_swarm(n.part)
Esave=c(Esave,min(bestgs))
plot(Esave,type="l")
}
assign_weights(weights,weightdim,bestp[which.min(bestgs),])
}
outsave=c()
par(mfrow=c(length(inputlist),1))
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability")
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
par(mfrow=c(1,1))
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
#=lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invobs,col="blue")
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
calparams<-get_params(inputs)
startvals_opt=calparams$startvals
rotvals_opt=calparams$rots
RandVec=calparams$RandVec
xsampsold=xsamps
xsamps=c(72,44)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
avec<-c(rep(rotvals_opt,length(xsamps)),rep(c(Re(startvals_opt),Im(startvals_opt)),length(xsamps)))
retrain=F
if (retrain){
n.part=20
initialize_swarm(n.part,type="direct")
Esave=c()
for (itt in 1:100){
step_swarm(n.part,type="direct")
Esave=c(Esave,min(bestgs))
#plot(Esave,type="l")
}
plot(Esave,type="l",xlab="steps",ylab="Error")
opt_params<-transform_to_params(bestp[which.min(bestgs),],inputlist)
}else{
opt_params<-transform_to_params(readRDS("../results/buoy_direct_opt.RdA"),inputlist)
}
stvals<-opt_params$stvals
rots<-opt_params$rots
#Append original trained data
rots<-rbind(rotvals_opt,rots)
stvals<-rbind(array(t(matrix(c(Re(startvals_opt),Im(startvals_opt)),ncol=2))),stvals)
xsamps=c(xsampsold,c(72,44))
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
stmat<-(matrix(stvals[iii,],nrow=2))
startvals<-(complex(n.s,stmat[1,],stmat[2,]))
coil_out<-(runcoil(RandVec,rots[iii,],startvals))
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
nn_inputs=sapply(1:length(inputlist[[1]]),function(g) do.call(rbind,lapply(inputlist,function(x)x[[g]])))
RandMat=t(matrix(rep(array(t(matrix(c(Re(RandVec),Im(RandVec)),ncol=2))),length(xsamps)),ncol=length(xsamps)))
nn_obj=cbind(rots,stvals,RandMat)
#We will use a custom loss function because we already know our coil parameters, so we can ignore those.
loss_focus<-function(y_true,y_pred){
importance_vector=rep(1,(n.s*2+3))
importance_vector[4:(n.s*2+3)]=100000
k_mean((y_true[,1:(n.s*2+3)]-y_pred[,1:(n.s*2+3)])^2*importance_vector)
}
retrain=F
if(retrain){
model %>%compile(loss=loss_focus,optimizer="adam")
history<-model%>%fit(
nn_inputs,
nn_obj,
epochs=1000,
batch_size=1
)
}else{
set_weights(model,readRDS("../results/buoy_full_neural.RdA"))
}
xsamps=c(3,72,44)
inout<-gen_in_out(dfs,xsamps)
inputlist<-inout[[1]]
outputs<-inout[[2]]
outsave=c()
for (iii in 1:length(inputlist)){
inputs=inputlist[[iii]]
coil_out=pop_coil(inputs,readout = T)
plot(outputs[iii,],col="blue",type="l",xlab="lookforward timesteps",ylab="Probability",main=paste0("Window ",iii))
matlines(coil_out[[1]],col="grey")
lines(coil_out[[1]][,1],col="red")
outsave=rbind(outsave,coil_out[[1]][,1])
}
legend("topright",col=c("blue","red","grey"),c("Observed","Modeled","Virtual States"),lwd=1)
plot(df[[objective]][-(1:lookback)],type="l",lwd=1.5,xlab="timesteps",ylab=objective,col="blue")
for (ix in 1:length(xsamps)){
invres=invertscaling(outsave[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
invobs=invertscaling(outputs[ix,],scalesaves[dim(scalesaves)[1],],scaleran)
lines(xsamps[ix]:(xsamps[ix]+lookforward-1),invres,col="red",lwd=2)
}
legend("topleft",col=c("blue","red"),c("Observed","Modeled"),lwd=1)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(neuralcoil)
#Load in Ball-in-Box data:
data("exampledata_ballinbox")
out_goal=as.numeric(exampledata_ballinbox)
matplot(exampledata_ballinbox,type="l",lwd=2,xlab = "Time",ylab="Probability",main="State Probability Dynamics")
legend("topright", colnames(P.df),col=seq_len(dim(P.df)[2]),cex=0.8,fill=seq_len(dim(P.df)[2]))
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(neuralcoil)
#Load in Ball-in-Box data:
data("exampledata_ballinbox")
out_goal=as.numeric(exampledata_ballinbox)
matplot(exampledata_ballinbox,type="l",lwd=2,xlab = "Time",ylab="Probability",main="State Probability Dynamics")
legend("topright", colnames(exampledata_ballinbox),col=seq_len(dim(exampledata_ballinbox)[2]),cex=0.8,fill=seq_len(dim(exampledata_ballinbox)[2]))
colnames(exampledata_ballinbox)
#Load in Ball-in-Box data:
data("exampledata_ballinbox")
out_goal=as.numeric(exampledata_ballinbox)
matplot(exampledata_ballinbox,type="l",lwd=2,xlab = "Time",ylab="Probability",main="State Probability Dynamics")
legend("topright", paste("State",1:4),col=seq_len(4),cex=0.8,fill=seq_len(dim(exampledata_ballinbox)[2]))
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(neuralcoil)
#Load in Ball-in-Box data:
data("exampledata_ballinbox")
out_goal=as.numeric(exampledata_ballinbox)
matplot(exampledata_ballinbox,type="l",lwd=2,xlab = "Time",ylab="Probability",main="State Probability Dynamics")
legend("topright", paste("State",1:4),col=seq_len(4),cex=0.8,fill=seq_len(dim(exampledata_ballinbox)[2]))
#User Selections----
n.s=dim(exampledata_ballinbox)[2]#number of states
sym=F   #Parameter Symmetry
loc=F #Locality
cont=T #Parameter Physicality Controls
sub.num=1 #Number of conserved subgroups
vfara_inert=1 #inertia
vfara_init=1 #initial inertia
Tlen=dim(exampledata_ballinbox)[1] #Steps to run coil
buildcoil(n.s,sym=F)
#Number of needed parameters
L=dim(CoilVals)[1]*2+3+n.s*2
retrain=F
if (retrain){
#Particle Swarm Optimizer
n.part=100#number of particles
w=0.9 #velocity factor
g_p=0.4#position influence factor
g_g=0.4#swarm influence factor
initialize_swarm_full(n.part,L,setrots=c(2,5,5))
for (itt in 1:10){
if (itt<400){
slseq=array(matrix(seq(1:length(out_goal)),ncol=n.s)[1:round(Tlen/2),])
#slseq=c(1:15,26:36,51:61,76:86)
}else{
slseq=1:length(out_goal)
}
#slseq=1:length(out_goal)
step_swarm_full(n.part,L,setrots=c(2,5,5))
matplot(t(outmat),col="grey",lty=1,type="l")
lines(out_goal,col="blue")
print(itt)
}
best_weights=best_p[which.min(apply(best_p_res,1,function(x)optf(x,out_goal,slseq))),]
}else{
best_weights=readRDS("../results/ballinbox_weights_final.RdA")
}
coil_out=pop_coil_full(best_weights)
Pmat=coil_out[[1]]
complex_states=coil_out[[2]]
matplot(Pmat,type="l",lwd=2,xlab = "Time",ylab="Probability",main="State Probability Dynamics")
matlines(exampledata_ballinbox)
legend("topright", paste("State",1:4),col=seq_len(4),cex=0.8,fill=seq_len(dim(exampledata_ballinbox)[2]))
par(mfrow = c(2, 2))
for (iP in 1:dim(Pmat)[2]){
plot(exampledata_ballinbox[,iP],type="l",xlab="Time",ylab="Probability",main = paste("State",iP,"Dynamics "))
lines(Pmat[,iP],lty=2)
}
par(mfrow = c(1,1))
ylims=c(min(Re(complex_states),Im(complex_states)),max(Re(complex_states),Im(complex_states)))
ylims[2]=ylims[2]+0.1
for (itt in 1:Tlen){
barplot(Pmat[itt,],space=0,ylab="Value",xlab="State",ylim=ylims)
lines(seq(0.5,length(complex_states[itt,])-0.5,1),Im(complex_states[itt,]),col="blue",lwd=2)
lines(seq(0.5,length(complex_states[itt,])-0.5,1),Re(complex_states[itt,]),col="red",lwd=2)
legend("bottomright",col=c("red","blue"),c("Real","Imaginary"),lty=1,lwd=2)
}
new_weights=best_weights
rdim=dim(CoilVals)[1]
new_weights[(rdim*2+1):(rdim*2+3)]=c(2,5.00001,5)
state.sel=1
matplot(pop_coil_full(new_weights)[[1]][,state.sel],pch=1,type="l",xlim=c(0,(Tlen)),lwd=2,ylim=c(0,1),xlab="Time",ylab=paste("State",state.sel,"Probability"),col="blue")
matlines(Pmat[,state.sel],lwd=2,type="l",xlim=c(0,(Tlen)),xlab="Time",ylab="P(s)",col="black")
legend("topright",col=c("blue","black"),c("New Rotation","Old Rotation"),lwd=2)
knitr::opts_chunk$set(
collapse = TRUE,warning = FALSE, message = FALSE
comment = "#>"
rmarkdown::render("vignettes/neuralcoilforecast.Rmd")
rmarkdown::render("vignettes/ballinbox.Rmd")
